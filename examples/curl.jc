struct std.string {
  data: !u8;
  capacity: i32;
  head: i32;
};

fn std.string std.string.init() {
  let string: std.string;
  return string;
}

@(import: "realloc")
extern "C" fn ?any libc.realloc(_: ?any, _: u64);

@(import: "memcpy")
extern "C" fn ?any libc.memcpy(_: !any, _: !any, _: u64);

@(import: "exit")
extern "C" fn libc.exit(code: i32);

fn std.string.resize(var !self, new: i32) {
  if .capacity < new {
    .data = libc.realloc(.data, new + 1)!;
    .capacity = new;
  }
  return;
}

fn std.string.append(var !self, string: !u8, bytes: i32) {
  if (.capacity - .head) < bytes {
    .resize(.capacity + bytes);
  }
  libc.memcpy(.data + .head, string, bytes);
  .head = .head + bytes;
  return;
}

type distinct CURL = !any;
type distinct CURLcode = i32;

@(import: "curl_easy_init")
extern "C" fn CURL CURL.init();

@(import: "curl_easy_cleanup")
extern "C" fn CURL.deinit(self);

@(import: "curl_easy_setopt")
extern "C" fn CURL.setopt(self, _: i32, ..);

@(import: "curl_easy_perform")
extern "C" fn CURLcode CURL.perform(self);

extern "C" fn printf(_: !u8, ..);

fn u64 string_write_fn(data: !u8, size: u64, nmemb: u64, str: var !std.string) {
  str.resize(((str.capacity -> i64) + size * nmemb) -> i32);
  str.append(data, (size * nmemb) -> i32);
  return size * nmemb;
}

fn main(argc: i32, argv: !!u8) {
  if argc < 2 {
    printf("Usage: %s <URL>\n", argv[0]);
    libc.exit(1);
  }

  let url = argv[1];

  let CURLOPT_URL: i32 = 10002;
  let CURLOPT_SSL_VERIFYPEER: i32 = 64;
  let CURLOPT_WRITEFUNCTION: i32 = 20011;
  let CURLOPT_WRITEDATA: i32 = 10001;

  let curl = CURL.init();
  curl.setopt(CURLOPT_URL, url);
  curl.setopt(CURLOPT_SSL_VERIFYPEER, 0);

  let string: std.string = .init();
  curl.setopt(CURLOPT_WRITEFUNCTION, string_write_fn);
  curl.setopt(CURLOPT_WRITEDATA, &string);

  curl.perform();

  printf("%s\n", string.data);
  return;
}
