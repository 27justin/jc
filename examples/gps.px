//import std.math;
std.math.sqrt :=/* @(extern: "C", import: "sqrtd")  */ fn (_: f64) -> f64
std.math.sin :=/* @(extern: "C", import: "sin")  */ fn (_: f64) -> f64
std.math.cos :=/* @(extern: "C", import: "cos")  */ fn (_: f64) -> f64
std.math.atan2 :=/* @(extern: "C", import: "atan2")  */ fn (_: f64, _: f64) -> f64
std.math.PI: f64 = 3.1415926

printf := fn (_: []u8, ..)

// Contracts define what a type has to be.
// Any type that matches a contract, can be coerced into it.
locatable := contract {
  lat: f64
  lon: f64
}

person := struct {
  name: []u8
  lat:  f64
  lon:  f64
}

landmark := struct {
  title:    []u8
  category: []u8
  lat:      f64
  lon:      f64
}

// This function only cares about `lat` and `lon`, by making it take a `locatable`
// any type with those members will immediately work.
get_distance_meters := fn(a: locatable, b: locatable) -> f64 {
    let earth_radius: f64 = 6371000.0;

    // Convert to radians
    let lat1 := a.lat * std.math.PI / 180.0;
    let lat2 := b.lat * std.math.PI / 180.0;
    let dlat := (b.lat - a.lat) * std.math.PI / 180.0;
    let dlon := (b.lon - a.lon) * std.math.PI / 180.0;

    let val := std.math.sin(dlat/2) * std.math.sin(dlat/2) +
               std.math.cos(lat1) * std.math.cos(lat2) *
               std.math.sin(dlon/2) * std.math.sin(dlon/2);

    let c := 2.0 * std.math.atan2(std.math.sqrt(val), std.math.sqrt(1.0 - val));

    earth_radius * c
}

main := fn() {
  let me := person {
    name: "Justin"
    lat: 51.5142
    lon: 7.4684
  };

  let phoenix_lake := landmark {
    title: "Ph√∂nixsee"
    category: "Nature"
    lat: 51.4901
    lon: 7.5130
  };

  let dist := get_distance_meters(me as locatable, phoenix_lake as locatable);
  printf("You are %f meters away from the landmark.", dist);
}
