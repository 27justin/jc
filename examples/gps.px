//import std.math;
std.math.sqrt :=/* @(extern: "C", import: "sqrtd")  */ fn (_: f64) -> f64

printf := fn (_: []u8, ..)

// Contracts define what a type has to be.
// Any type that matches a contract, can be coerced into it.
locatable := contract {
  lat: f64
  lon: f64
}

person := struct {
  name: []u8
  lat:  f64
  lon:  f64
}

landmark := struct {
  title:    []u8
  category: []u8
  lat:      f64
  lon:      f64
}

// This function only cares about `lat` and `lon`, by making it take a `locatable`
// any type with those members will immediately work.
get_distance := fn(a: locatable, b: locatable) -> f64 {
  let dx := a.lat - b.lat
  let dy := a.lon - b.lon
  std.math.sqrt(dx * dx + dy * dy)
}

main := fn() {
  let me := person {
    name: "Justin"
    lat: 51.5142
    lon: 7.4684
  }

  let phoenix_lake := landmark {
    title: "Ph√∂nixsee"
    category: "Nature"
    lat: 51.4901
    lon: 7.5130
  }

  let dist := get_distance(me as locatable, phoenix_lake as locatable)
  printf("You are %f meters away from the landmark.", dist)
}
