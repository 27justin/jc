jc.archive.open := fn (path: []u8) -> maybe<jc.archive> {
  if libc.stat(path, nil) == 0 {
    var archive := jc.archive.init()
    var magic: [4]u8 = zero

    var file := libc.fopen(path, "rb")
    defer file.close()

    libc.fread(file, magic)

    if magic != "CJ\x1b" {
      return maybe<jc.archive>.nil()
    }

    // Read settings size
    var settings_size: u32
    libc.fread(file, &settings_size -> !any, 4)

    var data: [settings_size]u8
    libc.fread(file, data)

    if settings_size >= sizeof(u64) {
      archive.chunk_size = (&data -> ?u64).*
    }

    var num_files: u64
    libc.fread(file, &num_files -> !any, 8)

    for 0..num_files {
      var entry: jc.archive.file_entry = .read(file)
    }

    maybe<jc.archive>.some(move archive)
  }
  return maybe<jc.archive>.nil()
}

  //import libc

//maybe<T> := struct {
//  value: T
//  filled: bool
//}

  maybe<T>.nil := fn () -> maybe<T> {
  maybe<T> {
    value: zero
    filled: false
  }
}

maybe<T>.some := fn (value: ^T) -> maybe<T> {
  maybe<T> {
    value: value
    filled: true
  }
}

//jc.file := struct {
//  name: []u8
//  permissions: i64
//  content: maybe<[]u8>
//}
//
//jc.settings := struct {
//  chunk_size: u64
//}
//
//jc.archive := struct {
//  items: std.vector<jc.file>
//}

jc.archive.init := fn () -> jc.archive {
}


