@(import: "malloc")
extern "C" fn ?any libc.calloc(_: u64, _: u64);
extern "C" fn void printf(_: !u8, ..);

struct std.mem.arena {
  pool: ?any;
  size: u64;
  head: u64;
};

fn std.mem.arena std.mem.arena.init(bytes: u64) {
  var arena: std.mem.arena;

  arena.pool = libc.calloc(bytes, 1);
  arena.head = 0;
  arena.size = bytes;
  return arena;
}

fn bool std.mem.arena.full(!self) {
  return .size == .head;
}

fn ?any std.mem.arena.alloc(var !self, bytes: u64) {
  // When we are full, we return nil.
  if .full() {
    return nil;
  }

  //// Now we check if bytes even fits.
  // if (.head + bytes) > .size {
  //   return nil;
  // }

  // If all pass, we can move our head.
  .head = .head + bytes;
  let ptr = ((.pool -> u64) + .head) -> ?any;
  return ptr;
}

fn i32 main(argc: i32, argv: !!u8) {
  var arena: std.mem.arena = .init(8);
  let int: !i32 = arena.alloc(4)!;
  printf("%p\n", int);

  let int2: !i32 = arena.alloc(4)!;
  printf("%p\n", int2);

  let int3: ?i32 = arena.alloc(4);
  printf("%p\n", int3);

  return 0;
}
